```
被代理服务器---代理服务器---客户端 C
                  |       \
              客户端 A   客户端 B 
```

一个客户端连接时代理服务器的过程为：
1. 监听端口可读
2. 接受一个新 socket
3. 连接到被代理服务器，产生一个新 socket

由此可知，一个客户端的连接会产生 2 个新的 socket，将这两个 socket 封装，类名为 Connection ，指一个从客户端到被代理服务器的抽象“连接”。

大部分时候 Connection 中没有包的交互，一般而言是两个 sockect 都不可读。但同时也有其他情况：

| 被代理服务器不可读 | 被代理服务器不可写 | 客户端不可读 | 客户端不可写 |
| :----------------: | :----------------: | :----------: | :----------: |
|         x          |                    |       x      |              |
|                    |          x         |              |       x      |
|         x          |          x         |              |              |
|                    |                    |       x      |       x      |

*考虑加入一个缓冲区队列在不可写时也能够读入，在实现时也可以做这方面的考虑*

当然还有可能是几种状态的叠加（更麻烦了）。那这些情况下 Connection 是“空闲”的。

如何确定 Connection 开始需要活动？一种解决方案是：将引发“空闲”状态的因素经行监听。以 Select函数（还没了解 epoll ）举个例子：

假设某时两个 socket 都不可读，此时 Connection 空闲。将两个 socket 加入 select 的读集合。 那么当 select 返回正值，那么 socket 中一定有一个可读，即 Connection 可以进入“活动”状态。

每次 Connection 结束“活动”状态，意为 Conntction 再次进入“空闲”状态。需要监听的对应 socket 可能发生改变。

再定义一个类：Top，负责管理 Connection 的接入、断开，是代理服务器代码的顶层部分，日志的部分也在这里面，或者抽象出去做个封装。

那每一次循环时，Top 从 Connection 拿取需要监听可读或可写的 socket 进入 epoll 并阻塞。当 epoll 返回意为某一个 Connection 进入“活动”状态，此时处理进入“活动”状态的 Connection ，并结束这一次循环。

更详细的想法查看该目录下的其他 \*.cpp、\*.h 文件。